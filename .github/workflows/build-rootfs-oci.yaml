# Copyright 2022 Antoine Martin
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# cSpell: ignore gomplate toupper

name: "Build and Push Custom Root FS as OCI Image"

on:
  workflow_dispatch:
    inputs:
      flavor:
        description: 'Root FS flavor'
        required: true
        default: 'arch'
        type: choice
        options:
          - ubuntu
          - arch
          - alpine
          - debian
          - opensuse
  push:
    branches: [deploy/images]
  schedule:
    # Run every Sunday at 2:00 AM UTC
    - cron: '0 2 * * 0'

env:
  REGISTRY: ghcr.io
  FLAVOR: alpine
  VERSION: "3.22.1"
  IMAGE_NAME: "${{ github.repository }}/alpine"
  ARCH_DEFAULT_VERSION: "2025.08.01"
  ALPINE_DEFAULT_VERSION: "3.22.1"

jobs:
  set-variables:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-vars.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - name: Download gomplate
        run: |-
          sudo curl -o /usr/local/bin/gomplate -sSL https://github.com/hairyhenderson/gomplate/releases/download/v4.3.3/gomplate_linux-amd64
          sudo chmod +x /usr/local/bin/gomplate
      - name: Set variables from inputs or defaults
        id: set-vars
        run: |
          # Generate the matrix
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Using inputs from workflow dispatch"
            matrix=$(gomplate -f .github/templates/builtins_matrix.json.tpl | jq -c '.include[] | select(.flavor == "${{ inputs.flavor }}") | { include: [.]}')
          else
            echo "Using matrix for deploy/images branch or scheduled build"
            matrix=$(gomplate -f .github/templates/builtins_matrix.json.tpl | jq -c '.')
          fi
          echo "matrix=$matrix" >> $GITHUB_OUTPUT
          echo "Final values:"
          echo "Matrix: $matrix"

  build-and-push-rootfs:
    runs-on: ubuntu-latest
    needs: [set-variables]
    strategy:
      matrix: ${{ fromJson(needs.set-variables.outputs.matrix) }}
      fail-fast: false
    permissions:
      contents: read
      packages: write
    steps:
      - name: Set environment variables
        run: |
          echo "FLAVOR=${{ matrix.flavor }}" >> $GITHUB_ENV
          echo "VERSION=${{ matrix.version }}" >> $GITHUB_ENV
          echo "UPSTREAM_URL=${{ matrix.url }}" >> $GITHUB_ENV
          echo "IMAGE_NAME=${GITHUB_REPOSITORY@L}/${{ matrix.flavor }}" >> $GITHUB_ENV

      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Download gomplate
        run: |-
          sudo curl -o /usr/local/bin/gomplate -sSL https://github.com/hairyhenderson/gomplate/releases/download/v4.3.3/gomplate_linux-amd64
          sudo chmod +x /usr/local/bin/gomplate
      - name: Set up build environment
        run: |
          sudo apt-get update
          sudo apt-get install -y libarchive-tools

      - name: Download base filesystem
        run: |
          curl -L "$UPSTREAM_URL" -o base.tar.gz

      - name: Rebuild if this is Arch
        if: ${{ env.FLAVOR == 'arch' }}
        shell: bash
        run: |
          mv base.tar.gz origfs.tar.zst
          sudo bsdtar -xpkf origfs.tar.zst
          sudo bsdtar -zcpf base.tar.gz -C root.x86_64 `ls root.x86_64`

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get WSL version from rootfs
        id: get-wsl-version
        run: |
          # Output the SHA256 checksum of the rootfs tarball
          WSL_BASE_DIGEST=$(sha256sum base.tar.gz | awk '{print toupper($1)}')
          echo "WSL_BASE_DIGEST=$WSL_BASE_DIGEST" >> $GITHUB_OUTPUT
          echo "WSL_BASE_SIZE=$(stat -c%s base.tar.gz)" >> $GITHUB_OUTPUT

          echo "Extracting OS information from the archive"
          eval $(bsdtar -xOf base.tar.gz etc/os-release usr/lib/os-release | grep -v '^ *#' | sed 's/^/export WSL_/')
          echo "Extracted the following information:"
          env | grep WSL_
          if [ -n "${WSL_VERSION_ID}" ]; then
            echo "Version from root fs is ${WSL_VERSION_ID}. Taking it instead of $VERSION"
            echo "VERSION=$WSL_VERSION_ID" >> $GITHUB_ENV
          elif [ -n "${WSL_IMAGE_VERSION}" ]; then
            echo "Version from rootfs is ${WSL_IMAGE_VERSION}. Taking it instead of $VERSION"
            echo "VERSION=$WSL_IMAGE_VERSION" >> $GITHUB_ENV
          fi
          if [ -n "${WSL_ID}" ]; then
            echo "Name from rootfs is ${WSL_ID}. Taking it instead of $FLAVOR"
            echo "FLAVOR=$WSL_ID" >> $GITHUB_ENV
            echo "IMAGE_NAME=${GITHUB_REPOSITORY@L}/${WSL_ID}" >> $GITHUB_ENV
          fi
          echo "Put all extracted variables into the output"
          env | grep WSL_ >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata for base image
        id: meta-base
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-base
          tags: |
            type=raw,value=${{ env.VERSION }}
            type=raw,value=latest

      - name: Create Dockerfile for base Linux image
        run: |
          WSL_UID=0 \
          WSL_ROOTFS_TAR_GZ=base.tar.gz \
          WSL_USERNAME=root \
          WSL_CONFIGURED=false \
          WSL_TYPE=base \
          WSL_SIZE=${{ steps.get-wsl-version.outputs.WSL_BASE_SIZE }} \
          gomplate -f .github/templates/Builtin.dockerfile.tpl -o Dockerfile.base

      - name: Build and push base Linux image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.base
          push: true
          tags: ${{ steps.meta-base.outputs.tags }}
          labels: ${{ steps.meta-base.outputs.labels }}
          platforms: linux/amd64

      - name: Build custom rootfs
        id: build-rootfs
        run: |
          # Extract base rootfs
          mkdir -p build
          sudo bsdtar -zxpkf base.tar.gz -C build

          # Configure the environment
          sudo cp -f /etc/resolv.conf build/etc/resolv.conf
          sudo mount -o bind /dev build/dev
          sudo mount -o bind /proc build/proc
          sudo mount -o bind /sys build/sys

          # Install configuration scripts
          sudo /usr/bin/install -m 740 -o root -g root ./p10k.zsh build/p10k.zsh
          sudo /usr/bin/install -m 740 -o root -g root ./configure.sh build/configure.sh

          # Run configuration
          sudo chroot --userspec=root:root build ./configure.sh

          # Cleanup
          sudo rm -f build/p10k.zsh build/configure.sh
          sudo umount -l build/{sys,proc,dev}

          # Create final rootfs tarball
          sudo bsdtar -zcpf ${FLAVOR}.${VERSION}.rootfs.tar.gz -C build `ls build`

          # Output the SHA256 checksum of the rootfs tarball
          WSL_DIGEST=$(sha256sum ${FLAVOR}.${VERSION}.rootfs.tar.gz | awk '{print toupper($1)}')
          echo "WSL_DIGEST=$WSL_DIGEST" >> $GITHUB_OUTPUT
          echo "WSL_SIZE=$(stat -c%s ${FLAVOR}.${VERSION}.rootfs.tar.gz)" >> $GITHUB_OUTPUT


      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ env.VERSION }}
            type=raw,value=latest
      - name: Create Dockerfile for OCI image
        run: |
          WSL_UID=1000 \
          WSL_ROOTFS_TAR_GZ=${FLAVOR}.${VERSION}.rootfs.tar.gz \
          WSL_USERNAME="${FLAVOR}" \
          WSL_CONFIGURED=true \
          WSL_TYPE=configured \
          WSL_SIZE=${{ steps.build-rootfs.outputs.WSL_SIZE }} \
          gomplate -f .github/templates/Builtin.dockerfile.tpl -o Dockerfile.configured

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.configured
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64

      - name:  Generate Image JSON metadata
        run: |
          WSL_UID=0 \
          WSL_SUFFIX="-base" \
          WSL_USERNAME=root \
          WSL_CONFIGURED=false \
          WSL_DIGEST="${{ steps.get-wsl-version.outputs.WSL_BASE_DIGEST }}" \
          WSL_SIZE=${{ steps.get-wsl-version.outputs.WSL_BASE_SIZE }} \
          WSL_TAGS="${{ steps.meta-base.outputs.tags }}" \
          gomplate -f .github/templates/rootfs.json.tpl -o ${{ env.FLAVOR }}-base.rootfs.json

          WSL_UID=1000 \
          WSL_SUFFIX="" \
          WSL_USERNAME="$FLAVOR" \
          WSL_CONFIGURED=true \
          WSL_DIGEST="${{ steps.build-rootfs.outputs.WSL_DIGEST }}" \
          WSL_SIZE=${{ steps.build-rootfs.outputs.WSL_SIZE }} \
          WSL_TAGS="${{ steps.meta.outputs.tags }}" \
          gomplate -f .github/templates/rootfs.json.tpl -o ${{ env.FLAVOR }}.rootfs.json

      - name: Upload JSON metadata
        uses: actions/upload-artifact@v4
        with:
          name: ${{ hashFiles('*.rootfs.json') }}
          path: "*.rootfs.json"

      - name: Output version information
        id: digest
        run: |
          echo "Image pushed successfully!"
          echo "Registry: ${{ env.REGISTRY }}"
          echo "Image: ${{ env.IMAGE_NAME }}"
          echo "Tags: ${{ steps.meta.outputs.tags }}"
          echo "Flavor: ${FLAVOR}"
          echo "Version: ${VERSION}"

  collect-rootfs-metadata:
    runs-on: ubuntu-latest
    needs: build-and-push-rootfs
    if: ${{ !cancelled() && github.ref == 'refs/heads/deploy/images' }}
    outputs:
      rootfs-metadata: ${{ steps.collect.outputs.rootfs_metadata }}
    steps:
      - uses: actions/download-artifact@v4
      - id: collect
        run: |
          rootfs_metadata="$(cat */*.rootfs.json | jq -c --slurp .)"
          echo "rootfs_metadata=$rootfs_metadata" >> $GITHUB_OUTPUT

  publish-rootfs-metadata:
    runs-on: ubuntu-latest
    needs: collect-rootfs-metadata
    if: ${{ !cancelled() && github.ref == 'refs/heads/deploy/images' }}
    permissions:
      contents: write
    steps:
      - name: Checkout gh-pages branch
        uses: actions/checkout@v4
        with:
          ref: rootfs

      - name: Write rootfs metadata to builtins.rootfs.json
        run: |
          cat << EOF | jq -M '.' > builtins.rootfs.json
          ${{ needs.collect-rootfs-metadata.outputs.rootfs-metadata }}
          EOF

      - name: Commit and push distributions.json
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add builtins.rootfs.json
          git commit -m "Update builtins.rootfs.json with latest rootfs metadata" || exit 0
          git push
