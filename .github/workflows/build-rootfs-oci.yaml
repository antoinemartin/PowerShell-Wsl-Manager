# Copyright 2022 Antoine Martin
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: "Build and Push Custom Root FS as OCI Image"

on:
  workflow_dispatch:
    inputs:
      flavor:
        description: 'Root FS flavor'
        required: true
        default: 'arch'
        type: choice
        options:
          - ubuntu
          - arch
          - alpine
          - debian
          - opensuse
      version:
        description: 'Version tag for the image. For other than Arch and Alpine, it should be latest'
        required: true
        default: '2025.08.01'
        type: string
  push:
    branches: [deploy/images]
  schedule:
    # Run every Sunday at 2:00 AM UTC
    - cron: '0 2 * * 0'

env:
  REGISTRY: ghcr.io
  FLAVOR: alpine
  VERSION: "3.22.1"
  IMAGE_NAME: "${{ github.repository }}/alpine"
  ARCH_DEFAULT_VERSION: "2025.08.01"
  ALPINE_DEFAULT_VERSION: "3.22.1"

jobs:
  set-variables:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-vars.outputs.matrix }}
    steps:
      - name: Set variables from inputs or defaults
        id: set-vars
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Using inputs from workflow dispatch"
            echo "matrix={\"include\":[{\"flavor\":\"${{ inputs.flavor }}\",\"version\":\"${{ inputs.version }}\"}]}" >> $GITHUB_OUTPUT
          else
            echo "Using matrix for deploy/images branch or scheduled build"
            echo "matrix={\"include\":[{\"flavor\":\"arch\",\"version\":\"${{ env.ARCH_DEFAULT_VERSION }}\"},{\"flavor\":\"alpine\",\"version\":\"${{ env.ALPINE_DEFAULT_VERSION }}\"},{\"flavor\":\"ubuntu\",\"version\":\"latest\"},{\"flavor\":\"debian\",\"version\":\"latest\"},{\"flavor\":\"opensuse\",\"version\":\"latest\"}]}" >> $GITHUB_OUTPUT
          fi
          echo "Final values:"
          echo "Matrix: $(cat $GITHUB_OUTPUT | grep matrix= | cut -d= -f2)"

  build-and-push-rootfs:
    runs-on: ubuntu-latest
    needs: [set-variables]
    strategy:
      matrix: ${{ fromJson(needs.set-variables.outputs.matrix) }}
      fail-fast: false
    permissions:
      contents: read
      packages: write
    steps:
      - name: Set environment variables
        run: |
          echo "FLAVOR=${{ matrix.flavor }}" >> $GITHUB_ENV
          echo "VERSION=${{ matrix.version }}" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ github.repository }}/${{ matrix.flavor }}" >> $GITHUB_ENV

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up build environment
        run: |
          sudo apt-get update
          sudo apt-get install -y libarchive-tools

      - name: Set base URL for flavor
        id: set-base-url
        run: |
          UPPER_VERSION="${VERSION}"
          # check that the version is latest if not Arch or Alpine
          if [[ "${FLAVOR}" != "arch" && "${FLAVOR}" != "alpine" ]]; then
            if [[ "$VERSION" != "latest" ]]; then
              echo "Error: For ${FLAVOR}, version must be 'latest'. Got: $VERSION"
              exit 1
            fi
          fi
          # On alpine, the version should contain the revision but we need the version with only the minor release for the URL.
          # Verify the version format and fail if not the right one
          if [[ "${FLAVOR}" == "alpine" ]]; then
            if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+ ]]; then
              echo "Error: For alpine, version must be in the format 'X.Y.Z'. Got: $VERSION"
              exit 1
            fi
            # Now remove the revision on UPPER_VERSION
            UPPER_VERSION="${UPPER_VERSION%.*}"
          fi
          # On Arch, the version format should be YYYY.MM.DD. Check it.
          if [[ "${FLAVOR}" == "arch" ]]; then
            if [[ ! "$VERSION" =~ ^[0-9]{4}\.[0-9]{2}\.[0-9]{2}$ ]]; then
              echo "Error: For arch, version must be in the format 'YYYY.MM.DD'. Got: $VERSION"
              exit 1
            fi
          fi
          case "${FLAVOR}" in
            ubuntu)
              echo "base_url=https://cdimages.ubuntu.com/ubuntu-wsl/daily-live/current/questing-wsl-amd64.wsl" >> $GITHUB_OUTPUT
              ;;
            arch)
              echo "base_url=https://archive.archlinux.org/iso/${VERSION}/archlinux-bootstrap-${VERSION}-x86_64.tar.zst" >> $GITHUB_OUTPUT
              ;;
            alpine)
              echo "base_url=https://dl-cdn.alpinelinux.org/alpine/v${UPPER_VERSION}/releases/x86_64/alpine-minirootfs-${VERSION}-x86_64.tar.gz" >> $GITHUB_OUTPUT
              ;;
            debian)
              echo "base_url=https://doi-janky.infosiftr.net/job/tianon/job/debuerreotype/job/amd64/lastSuccessfulBuild/artifact/stable/rootfs.tar.xz" >> $GITHUB_OUTPUT
              ;;
            opensuse)
              echo "base_url=https://download.opensuse.org/tumbleweed/appliances/opensuse-tumbleweed-dnf-image.x86_64-lxc-dnf.tar.xz" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Unsupported flavor: ${FLAVOR}"
              exit 1
              ;;
          esac

      - name: Download base filesystem
        run: |
          curl -L "${{ steps.set-base-url.outputs.base_url }}" -o base.tar.gz

      - name: Rebuild if this is Arch
        if: ${{ env.FLAVOR == 'arch' }}
        shell: bash
        run: |
          mv base.tar.gz origfs.tar.zst
          sudo bsdtar -xpkf origfs.tar.zst
          sudo bsdtar -zcpf base.tar.gz -C root.x86_64 `ls root.x86_64`

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get WSL version from rootfs
        id: get-wsl-version
        run: |
          echo "Extracting OS information from the archive"
          eval $(bsdtar -xOf base.tar.gz etc/os-release usr/lib/os-release | sed 's/^/export WSL_/')
          echo "Extracted the following information:"
          env | grep WSL_
          if [ -n "${WSL_VERSION_ID}" ]; then
            echo "Version from root fs is ${WSL_VERSION_ID}. Taking it instead of $VERSION"
            echo "VERSION=$WSL_VERSION_ID" >> $GITHUB_ENV
          elif [ -n "${WSL_IMAGE_VERSION}" ]; then
            echo "Version from rootfs is ${WSL_IMAGE_VERSION}. Taking it instead of $VERSION"
            echo "VERSION=$WSL_VERSION_ID" >> $GITHUB_ENV
          fi
          if [ -n "${WSL_ID}" ]; then
            echo "Name from rootfs is ${WSL_ID}. Taking it instead of $FLAVOR"
            echo "FLAVOR=$WSL_ID" >> $GITHUB_ENV
          fi
          echo "Put all extracted variables into the output"
          env | grep WSL_ >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata for base image
        id: meta-base
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-base
          tags: |
            type=raw,value=${{ env.VERSION }}
            type=raw,value=latest

      - name: Create Dockerfile for base Linux image
        run: |
          cat << EOF > Dockerfile.base
          FROM scratch
          ADD base.tar.gz /
          LABEL org.opencontainers.image.source="https://github.com/${{ github.repository }}"
          LABEL org.opencontainers.image.description="WSL Base ${{ env.FLAVOR }} Linux Root FS"
          LABEL org.opencontainers.image.flavor="${{ env.FLAVOR }}"
          LABEL org.opencontainers.image.version="${{ env.VERSION }}"
          LABEL com.kaweezle.wsl.rootfs.uid="0"
          LABEL com.kaweezle.wsl.rootfs.username="root"
          LABEL com.kaweezle.wsl.rootfs.configured="false"
          EOF

      - name: Build and push base Linux image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.base
          push: true
          tags: ${{ steps.meta-base.outputs.tags }}
          labels: ${{ steps.meta-base.outputs.labels }}
          platforms: linux/amd64

      - name: Build custom rootfs
        run: |
          # Extract base rootfs
          mkdir -p build
          sudo bsdtar -zxpkf base.tar.gz -C build

          # Configure the environment
          sudo cp -f /etc/resolv.conf build/etc/resolv.conf
          sudo mount -o bind /dev build/dev
          sudo mount -o bind /proc build/proc
          sudo mount -o bind /sys build/sys

          # Install configuration scripts
          sudo /usr/bin/install -m 740 -o root -g root ./p10k.zsh build/p10k.zsh
          sudo /usr/bin/install -m 740 -o root -g root ./configure.sh build/configure.sh

          # Run configuration
          sudo chroot --userspec=root:root build ./configure.sh

          # Cleanup
          sudo rm -f build/p10k.zsh build/configure.sh
          sudo umount -l build/{sys,proc,dev}

          # Create final rootfs tarball
          sudo bsdtar -zcpf ${FLAVOR}.${VERSION}.rootfs.tar.gz -C build `ls build`


      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ env.VERSION }}
            type=raw,value=latest
      - name: Create Dockerfile for OCI image
        run: |

          cat << EOF > Dockerfile
          FROM scratch
          ADD ${FLAVOR}.${VERSION}.rootfs.tar.gz /
          LABEL org.opencontainers.image.source="https://github.com/${{ github.repository }}"
          LABEL org.opencontainers.image.description="WSL Custom Root FS - ${{ env.FLAVOR}}"
          LABEL org.opencontainers.image.flavor="${{ env.FLAVOR }}"
          LABEL org.opencontainers.image.version="${{ env.VERSION }}"
          LABEL org.opencontainers.image.base="${{ steps.set-base-url.outputs.base_url }}"
          LABEL com.kaweezle.wsl.rootfs.uid="1000"
          LABEL com.kaweezle.wsl.rootfs.username="${{ env.FLAVOR }}"
          LABEL com.kaweezle.wsl.rootfs.configured="true"
          USER ${{ env.FLAVOR }}
          EOF

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64

      - name:  Generate Image JSON metadata
        run: |
          cat << EOF > ${{ env.FLAVOR }}-base.rootfs.json
          {
            "Name": "${{ env.FLAVOR }}-base",
            "Os": "${FLAVOR@u}",
            "Url": "docker://ghcr.io/${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-base#latest",
            "Hash": {
              "Type": "docker"
            },
            "Release": "${{ env.VERSION }}",
            "Configured": false,
            "Username": "root",
            "Uid": 0
          }
          EOF
          cat << EOF > ${{ env.FLAVOR }}.rootfs.json
          {
            "Name": "${{ env.FLAVOR }}",
            "Os": "${FLAVOR@u}",
            "Url": "docker://ghcr.io/${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}#latest",
            "Hash": {
              "Type": "docker"
            },
            "Release": "${{ env.VERSION }}",
            "Configured": true,
            "Username": "${{ env.FLAVOR }}",
            "Uid": 1000
          }
          EOF

      - name: Upload JSON metadata
        uses: actions/upload-artifact@v4
        with:
          name: ${{ hashFiles('*.rootfs.json') }}
          path: "*.rootfs.json"

      - name: Generate image digest
        id: digest
        run: |
          echo "Image pushed successfully!"
          echo "Registry: ${{ env.REGISTRY }}"
          echo "Image: ${{ env.IMAGE_NAME }}"
          echo "Tags: ${{ steps.meta.outputs.tags }}"
          echo "Flavor: ${FLAVOR}"
          echo "Version: ${VERSION}"

  collect-rootfs-metadata:
    runs-on: ubuntu-latest
    needs: build-and-push-rootfs
    if: ${{ !cancelled() && github.ref == 'refs/heads/deploy/images' }}
    outputs:
      rootfs-metadata: ${{ steps.collect.outputs.rootfs_metadata }}
    steps:
      - uses: actions/download-artifact@v4
      - id: collect
        run: |
          rootfs_metadata="$(cat */*.rootfs.json | jq -c --slurp .)"
          echo "rootfs_metadata=$rootfs_metadata" >> $GITHUB_OUTPUT

  publish-rootfs-metadata:
    runs-on: ubuntu-latest
    needs: collect-rootfs-metadata
    if: ${{ !cancelled() && github.ref == 'refs/heads/deploy/images' }}
    permissions:
      contents: write
    steps:
      - name: Checkout gh-pages branch
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Create docs/assets directory
        run: |
          mkdir -p docs/assets

      - name: Write rootfs metadata to distributions.json
        run: |
          cat << EOF > docs/assets/distributions.json
          ${{ needs.collect-rootfs-metadata.outputs.rootfs-metadata }}
          EOF

      - name: Commit and push distributions.json
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add docs/assets/distributions.json
          git commit -m "Update distributions.json with latest rootfs metadata" || exit 0
          git push
